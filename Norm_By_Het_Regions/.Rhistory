}
colnames(areaDF)  <- cols
rownames(areaDF) <- rownames(exprs(eset))
return(areaDF)
}
print("Computing Areas...")
areasDF <- computeArea(xgene)
xout <- cbind(fData(xgene), areasDF)
write.csv(xout, paste0(outdir, "/area_geneLevel.csv"), row.names=F)
myMax <- function(x){
y <- abs(x)
if (all(is.na(y))){
return(list(NA, NA))
} else {
pos <- which.max(y)
times <- c("Left", "Right", "Mid", "Sides")
return(list(maxVal = x[pos],
maxTime = times[pos]))
}
}
## Get number of categories.
n <- length(levels(pData(xgene)$type))
ns <- list()
i <- 1
while (i < n+1){
ns[[i]] <- 1:4+(4*(i-1))
i <- i+1
}
## Convert de areasDF into a list of DFs separated by types.
areas <- list()
for (i in 1:length(ns)) {
areas[[i]] <- areasDF[,ns[[i]]]
}
types <- unique(phenoData(xgene)$type)
type <- phenoData(xgene)$type
times <- phenoData(xgene)$time
maxminTP <- max(sapply(types,function(x) min(times[type==x])))
minmaxTP <- min(sapply(types,function(x) max(times[type==x])))
mybreaks <- seq(maxminTP, minmaxTP, length.out=5)
sets <- 1:length(areas)
combs <- combn(sets, 2)
span <- mybreaks[3] - mybreaks[1]
titles <- c("Left", "Right", "Middle", "Sides")
areaDifs <- list()
for (i in 1:dim(combs)[2]){
one <- combs[1,i]
two <- combs[2,i]
dif1 <- as.data.frame((areas[[one]] - areas[[two]])/span)
names  <- paste0(colnames(areas[[one]]),
"_minus_",
colnames(areas[[two]]))
prefix <- paste0(strsplit(colnames(areas[[one]])[1], "_")[[1]][1],
"-",
strsplit(colnames(areas[[two]])[1], "_")[[1]][1])
names <- sapply(titles, function(x) paste(prefix, x, sep = "_"))
colnames(dif1) <- names
maxval <- apply(dif1, 1, function(x) myMax(x)[[1]])
maxtime <- apply(dif1, 1, function(x) myMax(x)[[2]])
mv <- paste0(prefix, "_MaxVal")
mt <- paste0(prefix, "_MaxTime")
dif1[mv] <- maxval
dif1[mt] <- maxtime
#dif2 <- -dif1
## prefix <- paste0(strsplit(colnames(areas[[two]])[1], "_")[[1]][1],
##                  "-",
##                  strsplit(colnames(areas[[one]])[1], "_")[[1]][1])
## names <- sapply(titles, function(x) paste(prefix, x, sep = "_"))
## colnames(dif2) <- names
areaDifs <- c(areaDifs, list(dif1))#, list(dif2))
}
allDifs <- do.call(cbind, areaDifs)
head(allDifs)
timetostage <- function(tp){
while(tp > 48){
tp = tp-48
}
return(tp)
}
getStage <- function(tp) {
if ((tp >= 0) & (tp < 26)) {stg = "ring"}
else if ((tp >= 26) & (tp < 38)) {stg = "troph"}
else if ((tp >= 38) & (tp <= 48)) {stg = "schizont"}
return(stg)
}
fracToStage <- function(frac, tps){
if (is.na(frac)){
return(NA)
} else if (frac == "Left"){
tp = tps[2]
getStage(tp)
} else if (frac == "Right"){
tp = tps[4]
getStage(tp)
} else if (frac == "Mid"){
tp = tps[3]
getStage(tp)
} else if (frac == "Sides"){
tp1 = tps[1]+(span/4)
tp2 = tps[4]+(span/4)
stg1 <- getStage(tp1)
stg2 <- getStage(tp2)
return(paste0(stg1,"-",stg2))
}
}
ncombs <- dim(combs)[2]
maxValCols <- seq(5, ncombs*6, 6)
maxTimeCols <- seq(6, ncombs*6, 6)
aMAFC <- cbind(allDifs[,c(maxValCols, maxTimeCols)])
timeCols <- (ncombs+1):(ncombs*2)
tps <- sapply(mybreaks, function(x) timetostage(x))
for (i in timeCols){
aMAFC[,i] <- sapply(aMAFC[,i], function(x) fracToStage(x, tps))
}
write.csv(allDifs, paste0(outdir, "/areaDiferences_geneLevel.csv"))
write.csv(aMAFC, paste0(outdir, "/aMAFC_geneLevel.csv"))
print("Plotting PCA..")
noNA <- xgene[complete.cases(exprs(xgene))]
df <- t(exprs(noNA))
df <- as.data.frame(df)
pca <- prcomp(df)
cmp1 <- format(round(summary(pca)$importance[2,1]*100, 2), nsmall = 2)
cmp2 <- format(round(summary(pca)$importance[2,2]*100, 2), nsmall = 2)
df_pca <- as.data.frame(pca$x)
df_pca$Type <- noNA@phenoData@data$type
df_pca$Time <- noNA@phenoData@data$time
p <- ggplot(df_pca, aes(x=PC1,y=PC2, col = Type, group = Type))
p <- p + geom_point(aes(size= Time))
p <- p + geom_path()
p <- p + scale_x_continuous(name=paste0("PC1: ", cmp1, "%"))
p <- p + scale_y_continuous(name=paste0("PC2: ", cmp2, "%"))
ggsave(p, filename = paste0(figPath, "PCA.png"), device = "png", dpi = "retina")
print("Plotting Expression Plots...")
expressionPlot <- function(type){
# Set df and lims depending on what we are plotting.
if (type == "gene"){
df = xgene
path = "/Ratio/Gene_Level/"
} else if (type == "gene_red"){
df = xgene_red
path = "/Red_Signal/Gene_Level/"
} else if (type == "probe"){
df = xprobe
path = "/Ratio/Probe_Level/"
} else if (type == "probe_red"){
df = xprobe_red
path = "/Red_Signal/Probe_Level/"
}
# Set ylims
ylim = c(min(exprs(df), na.rm = T), max(exprs(df), na.rm = T))
# Set number of plots
if (run_all_plots == "yes"){
nplots = dim(df)[1]
} else {
nplots = 20
}
# Main Loop
for (i in 1:nplots){
# Set gene for title or gene and probe for probe-level plots.
gn <- gsub("[/:;.]", "_", fData(df)$Gene_id[i])
if (type %in% c("probe", "probe_red")){
prb <- paste0(gsub("[/:;.]", "_" , fData(xprobe)$ProbeName[i]), "_")
} else {
prb <- ""
}
# Plot
graf <- melt(df[i,])
graf["Type"] <- xgene@phenoData@data$type
graf["Time"] <- xgene@phenoData@data$time
p <- ggplot(graf, aes(x = Time, y = value, col = Type, group = Type))
p <- p + geom_point(aes(color = Type, shape = Type)) + geom_line()
p <- p + coord_cartesian(ylim = ylim)
p <- p + ggtitle(gn)
ggsave(p, file=paste0(figPath, path, prb, gn, ".jpeg"),
device = "jpeg", width = 14, height = 10, units = "cm")
}
}
expressionPlot("gene")
expressionPlot("gene_red")
expressionPlot("probe")
expressionPlot("probe_red")
library(ggplot2)
2+2
df <- read.csv('/mnt/Disc4T/Projects/PhD_Project/Integrated/pca_onlyChip_table.csv')
head(df)
df <- read.csv('/mnt/Disc4T/Projects/PhD_Project/Integrated/pca_onlyChip_table.csv', sep='\t')
head(df)
p <- ggplot(df, aes(x=PC1,y=PC2))
import(ggplot)
library(ggplot)
library(ggplot2)
df <- read.csv('/mnt/Disc4T/Projects/PhD_Project/Integrated/pca_onlyChip_table.csv', sep='\t')
p <- ggplot(df, aes(x=PC1,y=PC2))
p <- p + geom_point()
p
head(df)
p <- ggplot(df, aes(x=PC1,y=PC2))
p <- p + geom_point(color=Variant)
p
p <- ggplot(df, aes(x=PC1,y=PC2, col = Variant))
p <- p + geom_point()
p
library(DESeq2)
install.packages('DESeq2')
BiocManager::install("DESseq2")
BiocManager::install("tximport")
library(DESseq2)
library(DESeq2)
BiocManager::install("DESeq2")
library(org.Pf.plasmo.db)
library(Biobase)
library(reshape2)
library(ggfortify)
library(tidyverse)
library(RColorBrewer)
library(sp)
sessionInfo()
library(tidyverse)
df <- read_csv('/mnt/Disc4T/Projects/PhD_Project/pca_metac_data.csv')
df
?read_csv
df <- read_csv('/mnt/Disc4T/Projects/PhD_Project/pca_metac_data.csv') %>%
rename(PC1 = `principal component 1`, PC2 = `principal component 2`)
df
df <- read_csv('/mnt/Disc4T/Projects/PhD_Project/pca_metac_data.csv') %>%
rename(PC1 = `principal component 1`, PC2 = `principal component 2`) %>%
select(PC1, PC2, Label)
df
ggplot(df, x = PC2, y = PC1, color = Label) +
goeom_point()
ggplot(df, x = PC2, y = PC1, color = Label) +
geom_point()
ggplot(df, aes(x = PC2, y = PC1, color = Label)) +
geom_point()
library(GenomicRanges)
library(plyranges)
BiocManager::install("plyranges")
library(plyranges)
library(tidyverse)
read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/Alignments/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort.bam')
chpi_68 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/Alignments/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort.bam')
chip_68 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/Alignments/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort.bam')
chip_68 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/Alignments/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort.bam')
chip_68 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/Alignments/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort.bam')
chip_68 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/RPKMs_NormInput/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort_bs50_smooth100.bdg')
chip_70 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/RPKMs_NormInput/chip_00070_NCV11_lib_00700AAC_TTAGGC_read_q5_sort_bs50_smooth100.bdg')
gr_68 <- makeGRangesFromDataFrame(chip_68, keep.extra.columns=TRUE)
chip_68
chip_68 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/RPKMs_NormInput/chip_00068_NCV9_lib_00698AAC_ATCACG_read_q5_sort_bs50_smooth100.bdg', col_names = F)
chip_68
chip_70 <- read_tsv('/mnt/Disc4T/Projects/Nuria/GDV1_ChIP-Seq/RPKMs_NormInput/chip_00070_NCV11_lib_00700AAC_TTAGGC_read_q5_sort_bs50_smooth100.bdg', col_names = F)
gr_68 <- makeGRangesFromDataFrame(chip_68, keep.extra.columns=TRUE)
?makeGRangesFromDataFrame
gr_68 <- makeGRangesFromDataFrame(chip_68, keep.extra.columns=TRUE, seqnames.field = 'X1', start.field = 'X2', end.field = 'X3')
gr_68
gr_68 <- makeGRangesFromDataFrame(chip_68, keep.extra.columns=TRUE, seqnames.field = 'X1', start.field = 'X2', end.field = 'X3')
gr_70 <- makeGRangesFromDataFrame(chip_70, keep.extra.columns=TRUE, seqnames.field = 'X1', start.field = 'X2', end.field = 'X3')
gr_68 - gr_70
gr_68$X4
gr_68$X4 - gr_70$X4
gr_68
mergeGRangesData(gr_68, gr_70, field = 'X4')
findOverlaps(gr_68, gr_70)
?findOverlaps
c(gr_68, gr_70)
library(edgeR)
?featureCounts
??featureCounts
install.packages('Rsubread')
BiocManager::install("Rsubread")
library(Rsubread)
peaks_dir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Peak_Calling_MACS2/'
peak_files <- c('1.2B_me_Macspeaks_peaks.narrowPeak', 'NF54_me_Macspeaks_peaks.narrowPeak')
library(tidyverse)
peaks_dir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Peak_Calling_MACS2/'
peak_files <- c('1.2B_me_Macspeaks_peaks.narrowPeak', 'NF54_me_Macspeaks_peaks.narrowPeak')
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_bed.bed'
peaks_df <- read_csv(peaks_file)
peaks_df
peaks_df <- read_tsv(peaks_file)
peaks_df
peaks_df <- read_tsv(peaks_file, col_names = FALSE)
peaks_df
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_bed.bed'
peaks_df <- read_tsv(peaks_file, col_names = FALSE)
peaks_df
peaks_df <- read_tsv(peaks_file, col_names = c('Chr', 'Start', 'End'))
peaks_df
## Convert to SAF (single annotation format)
peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
## Convert to SAF (single annotation format)
peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
## Load alignment data (bam files)
bamdir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Bams/'
bamfiles <- paste0(bamdir, c('1.2B_me_sort_q5.bam', 'NF54_me_renamed_sort_q5.bam'))
bamfiles
## Convert to SAF (single annotation format)
peaks_saf <- peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
feat_counts <- featureCounts(files = bamfiles, annot.ext = peaks_saf, isPairedEnd = T, requireBothEndsMapped = T, nthreads = 4)
feat_counts
feat_counts$counts
head(feat_counts$counts)
raw.counts <- feat_counts$counts
## Use edgeR to calculate normalizing factors
NormFactor <- calcNormFactors(object = raw.counts, method = "TMM")
NormFactor
NormFactor.rle <- calcNormFactors(object = raw.counts, method = "RLE")
NormFactor.rle
## Use edgeR to calculate normalizing factors
NormFactor <- calcNormFactors(object = raw.counts, method = "TMM")
## raw library size:
LibSize <- colSums(raw.counts)
LibSize
## calculate size factors:
SizeFactors <- NormFactor * LibSize / 1000000
## Reciprocal, please read section below:
SizeFactors.Reciprocal <- 1/SizeFactors
SizeFactors
SizeFactors.Reciprocal
SizeFactors
## Reciprocal, please read section below:
SizeFactors.Reciprocal <- 1/SizeFactors
SizeFactors.Reciprocal
## Create output table
as_tibble(bamfiles, SizeFactors.Reciprocal)
## Create output table
as_tibble(Files <- bamfiles, Factors <- SizeFactors.Reciprocal)
## Create output table
as_tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal)
## Create output table
as_tibble(2, Files = bamfiles, Factors = SizeFactors.Reciprocal)
## Create output table
tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal)
## Create output table
tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal) %>%
write_tsv('bamfiles_and_factors.tsv')
wd <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/'
setwd(wd)
## Create output table
tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal) %>%
write_tsv('bamfiles_and_factors.tsv')
## Load Common Peaks File
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_ALL_me_files.bed'
library(edgeR)
library(Rsubread)
library(tidyverse)
wd <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/'
setwd(wd)
## Load Common Peaks File
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_ALL_me_files.bed'
peaks_df <- read_tsv(peaks_file, col_names = c('Chr', 'Start', 'End'))
## Convert to SAF (single annotation format)
peaks_saf <- peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
## Load alignment data (bam files)
bamdir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Bams/'
bamfiles <- paste0(bamdir, list.dirs(bamdir, pattern = '_q5.bam'))
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '_q5.bam'))
bamfiles
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '*_me_*_q5.bam'))
bamfiles
## Load alignment data (bam files)
bamdir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Bams/'
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '*_me_*_q5.bam'))
bamfiles
?list.files
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '*_q5.bam'))
bamfiles
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_me_.*_q5.bam'))
bamfiles
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_me_.*$_q5.bam'))
bamfiles
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_me_.*_q5.bam$'))
bamfiles
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_me_.*_q5.bam$'))
bamfiles
## Call featureCounts to get counts matrix
feat_counts <- featureCounts(files = bamfiles, annot.ext = peaks_saf, isPairedEnd = T, requireBothEndsMapped = T, nthreads = 8)
raw.counts <- feat_counts$counts
head(raw.counts)
## Use edgeR to calculate normalizing factors
NormFactor <- calcNormFactors(object = raw.counts, method = "TMM")
NormFactor.rle <- calcNormFactors(object = raw.counts, method = "RLE")
## Raw library size:
LibSize <- colSums(raw.counts)
## Calculate size factors by which we shlould divide the raw coverage:
SizeFactors <- NormFactor * LibSize / 1000000
## Reciprocal (since we will be using deepTools bamCoverage --scaleFactors which multiply instead of dividing the raw coverage)
SizeFactors.Reciprocal <- 1/SizeFactors
## Create output table
tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal) %>%
write_tsv('bamfiles_and_factors.tsv')
wd <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/'
setwd(wd)
## Load Common Peaks File
#peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_ALL_me_files.bed'
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/join_peaks_sorted_merged.bed'
peaks_df <- read_tsv(peaks_file, col_names = c('Chr', 'Start', 'End'))
peaks_df
## Convert to SAF (single annotation format)
peaks_saf <- peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
## Load alignment data (bam files)
bamdir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Bams/'
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_me_.*_q5.bam$'))
## Call featureCounts to get counts matrix
feat_counts <- featureCounts(files = bamfiles, annot.ext = peaks_saf, isPairedEnd = T, requireBothEndsMapped = T, nthreads = 8)
raw.counts <- feat_counts$counts
## Use edgeR to calculate normalizing factors
NormFactor <- calcNormFactors(object = raw.counts, method = "TMM")
NormFactor.rle <- calcNormFactors(object = raw.counts, method = "RLE")
## Raw library size:
LibSize <- colSums(raw.counts)
## Calculate size factors by which we shlould divide the raw coverage:
SizeFactors <- NormFactor * LibSize / 1000000
## Reciprocal (since we will be using deepTools bamCoverage --scaleFactors which multiply instead of dividing the raw coverage)
SizeFactors.Reciprocal <- 1/SizeFactors
## Create output table
tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal) %>%
write_tsv('bamfiles_and_factors_join_peaks.tsv')
NormFactor
NormFactor.rle
library(edgeR)
library(Rsubread)
library(tidyverse)
wd <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/'
setwd(wd)
## Load Common Peaks File
#peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_ALL_me_files.bed'
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/join_peaks_sorted_merged.bed'
peaks_df <- read_tsv(peaks_file, col_names = c('Chr', 'Start', 'End'))
peaks_df
## Convert to SAF (single annotation format)
peaks_saf <- peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
## Load Common Peaks File
#peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_ALL_me_files.bed'
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/join_peaks_sorted_merged.bed'
peaks_df <- read_tsv(peaks_file, col_names = c('Chr', 'Start', 'End'))
## Convert to SAF (single annotation format)
peaks_saf <- peaks_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
## Load alignment data (bam files)
bamdir <- '/home/lucas/ISGlobal/Projects/Phd_Project/ChIP_Seq/Bams/'
bamfiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_me_.*_q5.bam$'))
## Call featureCounts to get counts matrix
feat_counts <- featureCounts(files = bamfiles, annot.ext = peaks_saf, isPairedEnd = T, requireBothEndsMapped = T, nthreads = 8)
raw.counts <- feat_counts$counts
## Use edgeR to calculate normalizing factors
NormFactor <- calcNormFactors(object = raw.counts, method = "TMM")
NormFactor.rle <- calcNormFactors(object = raw.counts, method = "RLE")
NormFactor
NormFactor.rle
## Raw library size:
LibSize <- colSums(raw.counts)
## Calculate size factors by which we shlould divide the raw coverage:
SizeFactors <- NormFactor * LibSize / 1000000
## Reciprocal (since we will be using deepTools bamCoverage --scaleFactors which multiply instead of dividing the raw coverage)
SizeFactors.Reciprocal <- 1/SizeFactors
## Create output table
tibble(Files = bamfiles, Factors = SizeFactors.Reciprocal) %>%
write_tsv('bamfiles_and_factors_join_peaks.tsv')
wd <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/'
setwd(wd)
## Load Common Peaks File
#peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/common_peaks_ALL_me_files.bed'
peaks_file <- '/mnt/Disc4T/Projects/Miniprojects/Norm_By_Het_Regions/join_peaks_sorted_merged.bed'
peaks_df <- read_tsv(peaks_file, col_names = c('Chr', 'Start', 'End'))
bins_df <- read_tsv(bins_file, col_names = c('Chr', 'Start', 'End'))
## Load whole genome binned for inputs
bins_file <- './whole_genome__binned_10000.bed'
bins_df <- read_tsv(bins_file, col_names = c('Chr', 'Start', 'End'))
bins_df
bins_saf <- bins_df %>%
select(Chr, Start, End) %>%
mutate(Strand = '+') %>%
mutate(GeneID = row_number())
bins_saf
infiles <- paste0(bamdir, list.files(bamdir, pattern = '.*_in_.*_q5.bam$'))
infiles
feat_counts_in <- featureCounts(files = infiles, annot.ext = bins_saf, isPairedEnd = T, requireBothEndsMapped = T, nthreads = 8)
raw.counts.in <- feat_counts_in$counts
NormFactor.in <- calcNormFactors(object = raw.counts.in, method = "TMM")
NormFactor.rle.in <- calcNormFactors(object = raw.counts.in, method = "RLE")
NormFactor.in
NormFactor.rle.in <- calcNormFactors(object = raw.counts.in, method = "RLE")
## Raw library size:
LibSize <- colSums(raw.counts)
LibSize.in <- colSums(raw.counts.in)
## Calculate size factors by which we shlould divide the raw coverage:
SizeFactors <- NormFactor * LibSize / 1000000
SizeFactors.in <- NormFactor.in * LibSize.in / 1000000
SizeFactors.Reciprocal.in <- 1/SizeFactors.in
SizeFactors.in
tibble(Files = infiles, Factors = SizeFactors.Reciprocal.in) %>%
write_tsv('bamfiles_and_factors_inputs_binned10000.tsv')
